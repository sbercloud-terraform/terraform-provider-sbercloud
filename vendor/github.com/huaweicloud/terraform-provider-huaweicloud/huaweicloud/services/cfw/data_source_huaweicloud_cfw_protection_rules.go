// Generated by PMS #147
package cfw

import (
	"context"
	"fmt"

	"github.com/hashicorp/go-multierror"
	"github.com/hashicorp/go-uuid"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/tidwall/gjson"

	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/config"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/helper/filters"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/helper/httphelper"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/helper/schemas"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/utils"
)

func DataSourceCfwProtectionRules() *schema.Resource {
	return &schema.Resource{
		ReadContext: dataSourceCfwProtectionRulesRead,

		Schema: map[string]*schema.Schema{
			"region": {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				Description: `Specifies the region in which to query the resource. If omitted, the provider-level region will be used.`,
			},
			"object_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Specifies the protected object ID.`,
			},
			"name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the rule name.`,
			},
			"type": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the rule type.`,
			},
			"direction": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the rule direction.`,
			},
			"rule_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the rule ID.`,
			},
			"status": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the rule status.`,
			},
			"action_type": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the rule action type.`,
			},
			"source": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the source address.`,
			},
			"destination": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the destination address.`,
			},
			"fw_instance_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the firewall instance ID.`,
			},
			"tags": {
				Type:     schema.TypeMap,
				Optional: true,
				Elem:     &schema.Schema{Type: schema.TypeString},
				ValidateFunc: func(v interface{}, _ string) ([]string, []error) {
					if keys, ok := v.(map[string]interface{}); ok && len(keys) > 1 {
						return nil, []error{fmt.Errorf("tags can take at most one key-value pair")}
					}
					return nil, nil
				},
				Description: `Specifies the key/value pairs to associate with the protection rule.`,
			},
			"records": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The protection rule list.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"rule_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The rule ID.`,
						},
						"name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The rule name.`,
						},
						"type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The rule type.`,
						},
						"status": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The rule status.`,
						},
						"description": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The rule description.`,
						},
						"action_type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The rule action type.`,
						},
						"destination": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The destination configuration.`,
							Elem:        dataRecDesElem(),
						},
						"service": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The service.`,
							Elem:        dataRecordsServiceElem(),
						},
						"address_type": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `The address type.`,
						},
						"long_connect_time_hour": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `The persistent connection duration (hour).`,
						},
						"long_connect_time_minute": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `The persistent connection duration (minute).`,
						},
						"long_connect_time_second": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `The persistent connection duration (second).`,
						},
						"long_connect_enable": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `Whether to support persistent connections.`,
						},
						"long_connect_time": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `The persistent connection duration.`,
						},
						"source": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The source configuration.`,
							Elem:        dataRecordsSourceElem(),
						},
						"tags": {
							Type:        schema.TypeMap,
							Computed:    true,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Description: `The tag of a rule.`,
						},
						"direction": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The direction of a rule.`,
						},
						"created_date": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The created time of a rule.`,
						},
						"last_open_time": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The last open time.`,
						},
					},
				},
			},
		},
	}
}

// dataRecordsServiceElem
// The Elem of "data.records.service"
func dataRecordsServiceElem() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"dest_port": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The destination port of the service.`,
			},
			"service_set_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The service group ID.`,
			},
			"service_set_name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The service group name.`,
			},
			"type": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `The service input type.`,
			},
			"source_port": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The source port.`,
			},
			"service_group": {
				Type:        schema.TypeList,
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `The service group list.`,
			},
			"protocol": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `The protocol type.`,
			},
			"custom_service": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The custom service.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"dest_port": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The destination port.`,
						},
						"description": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The custom service description.`,
						},
						"name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The custom service name.`,
						},
						"protocol": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `The protocol type of the custom service.`,
						},
						"source_port": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The source port of the custom service.`,
						},
					},
				},
			},
			"service_set_type": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `The service set type.`,
			},
			"protocols": {
				Type:        schema.TypeList,
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeInt},
				Description: `The protocols.`,
			},
		},
	}
}

// dataRecDesElem
// The Elem of "data.records.destination"
func dataRecDesElem() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"address_set_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The ID of the associated IP address group.`,
			},
			"region_list": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The region list of a rule.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"region_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The region ID of the destination.`,
						},
						"description_cn": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The Chinese description of a region.`,
						},
						"description_en": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The English description of a region.`,
						},
						"region_type": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `The region type.`,
						},
					},
				},
			},
			"domain_set_name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The name of domain group.`,
			},
			"domain_set_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The ID of the domain group.`,
			},
			"ip_address": {
				Type:        schema.TypeList,
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `The IP address list.`,
			},
			"address_group": {
				Type:        schema.TypeList,
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `The address group.`,
			},
			"type": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `The destination type.`,
			},
			"address_type": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `The destination address type.`,
			},
			"address": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The destination IP address.`,
			},
			"address_set_name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The IP address group name.`,
			},
			"domain_address_name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The name of the domain name address.`,
			},
			"address_set_type": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `The destination address set type.`,
			},
		},
	}
}

// dataRecordsSourceElem
// The Elem of "data.records.source"
func dataRecordsSourceElem() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"address_set_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The ID of the associated IP address group.`,
			},
			"region_list": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The region list of a rule.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"region_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The region ID.`,
						},
						"description_cn": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The Chinese description of a region.`,
						},
						"description_en": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The English description of a region.`,
						},
						"region_type": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `The region type.`,
						},
					},
				},
			},
			"ip_address": {
				Type:        schema.TypeList,
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `The IP address list.`,
			},
			"address_group": {
				Type:        schema.TypeList,
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `The address group.`,
			},
			"type": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `The source type.`,
			},
			"address_type": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `The address type.`,
			},
			"address": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The source IP address.`,
			},
			"address_set_name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The IP address group name.`,
			},
			"domain_address_name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The name of the domain address.`,
			},
			"address_set_type": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `The address set type.`,
			},
		},
	}
}

type ProtectionRulesDSWrapper struct {
	*schemas.ResourceDataWrapper
	Config *config.Config
}

func newProtectionRulesDSWrapper(d *schema.ResourceData, meta interface{}) *ProtectionRulesDSWrapper {
	return &ProtectionRulesDSWrapper{
		ResourceDataWrapper: schemas.NewSchemaWrapper(d),
		Config:              meta.(*config.Config),
	}
}

func dataSourceCfwProtectionRulesRead(_ context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	wrapper := newProtectionRulesDSWrapper(d, meta)
	listAclRulesRst, err := wrapper.ListAclRules()
	if err != nil {
		return diag.FromErr(err)
	}

	id, err := uuid.GenerateUUID()
	if err != nil {
		return diag.FromErr(err)
	}
	d.SetId(id)

	err = wrapper.listAclRulesToSchema(listAclRulesRst)
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

// @API CFW GET /v1/{project_id}/acl-rules
func (w *ProtectionRulesDSWrapper) ListAclRules() (*gjson.Result, error) {
	client, err := w.NewClient(w.Config, "cfw")
	if err != nil {
		return nil, err
	}

	uri := "/v1/{project_id}/acl-rules"
	params := map[string]any{
		"object_id":      w.Get("object_id"),
		"type":           w.Get("type"),
		"name":           w.Get("name"),
		"direction":      w.Get("direction"),
		"status":         w.Get("status"),
		"action_type":    w.Get("action_type"),
		"fw_instance_id": w.Get("fw_instance_id"),
		"source":         w.Get("source"),
		"destination":    w.Get("destination"),
	}
	params = utils.RemoveNil(params)
	return httphelper.New(client).
		Method("GET").
		URI(uri).
		Query(params).
		OffsetPager("data.records", "offset", "limit", 1024).
		Filter(
			filters.New().From("data.records").
				Where("rule_id", "=", w.Get("rule_id")).
				Filter(func(item gjson.Result) bool {
					tags := w.Get("tags")
					if tags == nil {
						return true
					}
					tagList := utils.ExpandResourceTagsMap(tags.(map[string]interface{}))
					key := tagList[0]["key"].(string)
					value := tagList[0]["value"].(string)
					return item.Get("tag.tag_key").String() == key && item.Get("tag.tag_value").String() == value
				}),
		).
		Request().
		Result()
}

func (w *ProtectionRulesDSWrapper) listAclRulesToSchema(body *gjson.Result) error {
	d := w.ResourceData
	mErr := multierror.Append(nil,
		d.Set("region", w.Config.GetRegion(w.ResourceData)),
		d.Set("records", schemas.SliceToList(body.Get("data.records"),
			func(record gjson.Result) any {
				return map[string]any{
					"rule_id":     record.Get("rule_id").Value(),
					"name":        record.Get("name").Value(),
					"type":        record.Get("type").String(),
					"status":      record.Get("status").String(),
					"description": record.Get("description").Value(),
					"action_type": record.Get("action_type").String(),
					"destination": schemas.SliceToList(record.Get("destination"),
						func(destination gjson.Result) any {
							return map[string]any{
								"address_set_id": destination.Get("address_set_id").Value(),
								"region_list": schemas.SliceToList(destination.Get("region_list"),
									func(regionList gjson.Result) any {
										return map[string]any{
											"region_id":      regionList.Get("region_id").Value(),
											"description_cn": regionList.Get("description_cn").Value(),
											"description_en": regionList.Get("description_en").Value(),
											"region_type":    regionList.Get("region_type").Value(),
										}
									},
								),
								"domain_set_name":     destination.Get("domain_set_name").Value(),
								"domain_set_id":       destination.Get("domain_set_id").Value(),
								"ip_address":          schemas.SliceToStrList(destination.Get("ip_address")),
								"address_group":       schemas.SliceToStrList(destination.Get("address_group")),
								"type":                destination.Get("type").Value(),
								"address_type":        destination.Get("address_type").Value(),
								"address":             destination.Get("address").Value(),
								"address_set_name":    destination.Get("address_set_name").Value(),
								"domain_address_name": destination.Get("domain_address_name").Value(),
								"address_set_type":    destination.Get("address_set_type").Value(),
							}
						},
					),
					"service": schemas.SliceToList(record.Get("service"),
						func(service gjson.Result) any {
							return map[string]any{
								"dest_port":        service.Get("dest_port").Value(),
								"service_set_id":   service.Get("service_set_id").Value(),
								"service_set_name": service.Get("service_set_name").Value(),
								"type":             service.Get("type").Value(),
								"source_port":      service.Get("source_port").Value(),
								"service_group":    schemas.SliceToStrList(service.Get("service_group")),
								"protocol":         service.Get("protocol").Value(),
								"custom_service": schemas.SliceToList(service.Get("custom_service"),
									func(customService gjson.Result) any {
										return map[string]any{
											"dest_port":   customService.Get("dest_port").Value(),
											"description": customService.Get("description").Value(),
											"name":        customService.Get("name").Value(),
											"protocol":    customService.Get("protocol").Value(),
											"source_port": customService.Get("source_port").Value(),
										}
									},
								),
								"service_set_type": service.Get("service_set_type").Value(),
								"protocols":        schemas.SliceToIntList(service.Get("protocols")),
							}
						},
					),
					"address_type":             record.Get("address_type").Value(),
					"long_connect_time_hour":   record.Get("long_connect_time_hour").Value(),
					"long_connect_time_minute": record.Get("long_connect_time_minute").Value(),
					"long_connect_time_second": record.Get("long_connect_time_second").Value(),
					"long_connect_enable":      record.Get("long_connect_enable").Value(),
					"long_connect_time":        record.Get("long_connect_time").Value(),
					"source": schemas.SliceToList(record.Get("source"),
						func(source gjson.Result) any {
							return map[string]any{
								"address_set_id": source.Get("address_set_id").Value(),
								"region_list": schemas.SliceToList(source.Get("region_list"),
									func(regionList gjson.Result) any {
										return map[string]any{
											"region_id":      regionList.Get("region_id").Value(),
											"description_cn": regionList.Get("description_cn").Value(),
											"description_en": regionList.Get("description_en").Value(),
											"region_type":    regionList.Get("region_type").Value(),
										}
									},
								),
								"ip_address":          schemas.SliceToStrList(source.Get("ip_address")),
								"address_group":       schemas.SliceToStrList(source.Get("address_group")),
								"type":                source.Get("type").Value(),
								"address_type":        source.Get("address_type").Value(),
								"address":             source.Get("address").Value(),
								"address_set_name":    source.Get("address_set_name").Value(),
								"domain_address_name": source.Get("domain_address_name").Value(),
								"address_set_type":    source.Get("address_set_type").Value(),
							}
						},
					),
					"tags":           w.setDataRecordsTag(record),
					"direction":      record.Get("direction").String(),
					"created_date":   record.Get("created_date").Value(),
					"last_open_time": record.Get("last_open_time").Value(),
				}
			},
		)),
	)
	return mErr.ErrorOrNil()
}

func (*ProtectionRulesDSWrapper) setDataRecordsTag(data gjson.Result) map[string]string {
	tags := make(map[string]string)

	tagArr := data.Get("tag").Array()
	for _, v := range tagArr {
		tags[v.Get("tag_key").String()] = v.Get("tag_value").String()
	}
	return tags
}
