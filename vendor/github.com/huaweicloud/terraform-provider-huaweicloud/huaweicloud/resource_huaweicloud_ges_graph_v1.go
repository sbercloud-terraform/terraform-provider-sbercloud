// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://www.github.com/huaweicloud/magic-modules
//
// ----------------------------------------------------------------------------

package huaweicloud

import (
	"reflect"
	"time"

	"github.com/chnsz/golangsdk"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/config"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/utils/fmtp"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/utils/logp"
)

func ResourceGesGraphV1() *schema.Resource {
	return &schema.Resource{
		Create: resourceGesGraphV1Create,
		Read:   resourceGesGraphV1Read,
		Delete: resourceGesGraphV1Delete,

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(30 * time.Minute),
			Delete: schema.DefaultTimeout(30 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"availability_zone": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"graph_size_type": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"region": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
				Computed: true,
			},

			"security_group_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"subnet_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"vpc_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"auto_assign": {
				Type:     schema.TypeBool,
				Optional: true,
				ForceNew: true,
			},

			"eip_id": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
			},

			"created": {
				Type:     schema.TypeString,
				Computed: true,
			},

			"edgeset_path": {
				Type:     schema.TypeList,
				Computed: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"path": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"status": {
							Type:     schema.TypeString,
							Computed: true,
						},
					},
				},
			},

			"private_ip": {
				Type:     schema.TypeString,
				Computed: true,
			},

			"public_ip": {
				Type:     schema.TypeString,
				Computed: true,
			},

			"schema_path": {
				Type:     schema.TypeList,
				Computed: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"path": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"status": {
							Type:     schema.TypeString,
							Computed: true,
						},
					},
				},
			},

			"version": {
				Type:     schema.TypeString,
				Computed: true,
			},

			"vertexset_path": {
				Type:     schema.TypeList,
				Computed: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"path": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"status": {
							Type:     schema.TypeString,
							Computed: true,
						},
					},
				},
			},
		},
	}
}

func resourceGesGraphV1UserInputParams(d *schema.ResourceData) map[string]interface{} {
	return map[string]interface{}{
		"terraform_resource_data": d,
		"auto_assign":             d.Get("auto_assign"),
		"availability_zone":       d.Get("availability_zone"),
		"eip_id":                  d.Get("eip_id"),
		"graph_size_type":         d.Get("graph_size_type"),
		"name":                    d.Get("name"),
		"region":                  d.Get("region"),
		"security_group_id":       d.Get("security_group_id"),
		"subnet_id":               d.Get("subnet_id"),
		"vpc_id":                  d.Get("vpc_id"),
	}
}

func resourceGesGraphV1Create(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*config.Config)
	client, err := config.GesV1Client(GetRegion(d, config))
	if err != nil {
		return fmtp.Errorf("Error creating sdk client, err=%s", err)
	}

	opts := resourceGesGraphV1UserInputParams(d)

	params, err := buildGesGraphV1CreateParameters(opts, nil)
	if err != nil {
		return fmtp.Errorf("Error building the request body of api(create), err=%s", err)
	}
	r, err := sendGesGraphV1CreateRequest(d, params, client)
	if err != nil {
		return fmtp.Errorf("Error creating GesGraphV1, err=%s", err)
	}

	timeout := d.Timeout(schema.TimeoutCreate)
	obj, err := asyncWaitGesGraphV1Create(d, config, r, client, timeout)
	if err != nil {
		return err
	}

	id, err := navigateValue(obj, []string{"graph", "id"}, nil)
	if err != nil {
		return fmtp.Errorf("Error constructing id, err=%s", err)
	}
	d.SetId(id.(string))

	return resourceGesGraphV1Read(d, meta)
}

func resourceGesGraphV1Read(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*config.Config)
	client, err := config.GesV1Client(GetRegion(d, config))
	if err != nil {
		return fmtp.Errorf("Error creating sdk client, err=%s", err)
	}

	res := make(map[string]interface{})

	v, err := sendGesGraphV1ReadRequest(d, client)
	if err != nil {
		return err
	}
	res["read"] = fillGesGraphV1ReadRespBody(v)

	return setGesGraphV1Properties(d, res)
}

func resourceGesGraphV1Delete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*config.Config)
	client, err := config.GesV1Client(GetRegion(d, config))
	if err != nil {
		return fmtp.Errorf("Error creating sdk client, err=%s", err)
	}

	url, err := replaceVars(d, "graphs/{id}", nil)
	if err != nil {
		return err
	}
	url = client.ServiceURL(url)

	logp.Printf("[DEBUG] Deleting Graph %q", d.Id())
	r := golangsdk.Result{}
	_, r.Err = client.Delete(url, &golangsdk.RequestOpts{
		OkCodes:      successHTTPCodes,
		JSONBody:     nil,
		JSONResponse: &r.Body,
		MoreHeaders:  map[string]string{"Content-Type": "application/json"},
	})
	if r.Err != nil {
		return fmtp.Errorf("Error deleting Graph %q, err=%s", d.Id(), r.Err)
	}

	_, err = asyncWaitGesGraphV1Delete(d, config, r.Body, client, d.Timeout(schema.TimeoutDelete))
	return err
}

func buildGesGraphV1CreateParameters(opts map[string]interface{}, arrayIndex map[string]int) (interface{}, error) {
	params := make(map[string]interface{})

	v, err := navigateValue(opts, []string{"availability_zone"}, arrayIndex)
	if err != nil {
		return nil, err
	}
	if e, err := isEmptyValue(reflect.ValueOf(v)); err != nil {
		return nil, err
	} else if !e {
		params["azCode"] = v
	}

	v, err = navigateValue(opts, []string{"graph_size_type"}, arrayIndex)
	if err != nil {
		return nil, err
	}
	if e, err := isEmptyValue(reflect.ValueOf(v)); err != nil {
		return nil, err
	} else if !e {
		params["graphSizeTypeIndex"] = v
	}

	v, err = navigateValue(opts, []string{"name"}, arrayIndex)
	if err != nil {
		return nil, err
	}
	if e, err := isEmptyValue(reflect.ValueOf(v)); err != nil {
		return nil, err
	} else if !e {
		params["name"] = v
	}

	v, err = expandGesGraphV1CreatePublicIp(opts, arrayIndex)
	if err != nil {
		return nil, err
	}
	if e, err := isEmptyValue(reflect.ValueOf(v)); err != nil {
		return nil, err
	} else if !e {
		params["publicIp"] = v
	}

	v, err = navigateValue(opts, []string{"region"}, arrayIndex)
	if err != nil {
		return nil, err
	}
	if e, err := isEmptyValue(reflect.ValueOf(v)); err != nil {
		return nil, err
	} else if !e {
		params["regionCode"] = v
	}

	v, err = navigateValue(opts, []string{"security_group_id"}, arrayIndex)
	if err != nil {
		return nil, err
	}
	if e, err := isEmptyValue(reflect.ValueOf(v)); err != nil {
		return nil, err
	} else if !e {
		params["securityGroupId"] = v
	}

	v, err = navigateValue(opts, []string{"subnet_id"}, arrayIndex)
	if err != nil {
		return nil, err
	}
	if e, err := isEmptyValue(reflect.ValueOf(v)); err != nil {
		return nil, err
	} else if !e {
		params["subnetId"] = v
	}

	v, err = navigateValue(opts, []string{"vpc_id"}, arrayIndex)
	if err != nil {
		return nil, err
	}
	if e, err := isEmptyValue(reflect.ValueOf(v)); err != nil {
		return nil, err
	} else if !e {
		params["vpcId"] = v
	}

	if len(params) == 0 {
		return params, nil
	}

	params = map[string]interface{}{"graph": params}

	return params, nil
}

func expandGesGraphV1CreatePublicIp(d interface{}, arrayIndex map[string]int) (interface{}, error) {
	req := make(map[string]interface{})

	v, err := navigateValue(d, []string{"eip_id"}, arrayIndex)
	if err != nil {
		return nil, err
	}
	if e, err := isEmptyValue(reflect.ValueOf(v)); err != nil {
		return nil, err
	} else if !e {
		req["eipId"] = v
	}

	v, err = expandGesGraphV1CreatePublicIpPublicBindType(d, arrayIndex)
	if err != nil {
		return nil, err
	}
	if e, err := isEmptyValue(reflect.ValueOf(v)); err != nil {
		return nil, err
	} else if !e {
		req["publicBindType"] = v
	}

	return req, nil
}

func expandGesGraphV1CreatePublicIpPublicBindType(d interface{}, arrayIndex map[string]int) (interface{}, error) {
	v, err := navigateValue(d, []string{"auto_assign"}, arrayIndex)
	if err != nil {
		return nil, err
	}
	if v1, ok := v.(bool); ok && v1 {
		return "auto_assgin", nil
	}

	v, err = navigateValue(d, []string{"eip_id"}, arrayIndex)
	if err != nil {
		return "", err
	}
	if v2, ok := v.(string); ok && v2 != "" {
		return "bind_existing", nil
	}
	return "", nil
}

func sendGesGraphV1CreateRequest(d *schema.ResourceData, params interface{},
	client *golangsdk.ServiceClient) (interface{}, error) {
	url := client.ServiceURL("graphs")

	r := golangsdk.Result{}
	_, r.Err = client.Post(url, params, &r.Body, &golangsdk.RequestOpts{
		OkCodes: successHTTPCodes,
	})
	if r.Err != nil {
		return nil, fmtp.Errorf("Error running api(create), err=%s", r.Err)
	}
	return r.Body, nil
}

func asyncWaitGesGraphV1Create(d *schema.ResourceData, config *config.Config, result interface{},
	client *golangsdk.ServiceClient, timeout time.Duration) (interface{}, error) {

	data := make(map[string]interface{})
	pathParameters := map[string][]string{
		"graphId": []string{"id"},
	}
	for key, path := range pathParameters {
		value, err := navigateValue(result, path, nil)
		if err != nil {
			return nil, fmtp.Errorf("Error retrieving async operation path parameter, err=%s", err)
		}
		data[key] = value
	}

	url, err := replaceVars(d, "graphs/{graphId}", data)
	if err != nil {
		return nil, err
	}
	url = client.ServiceURL(url)

	return waitToFinish(
		[]string{"200"},
		[]string{"100"},
		timeout, 1*time.Second,
		func() (interface{}, string, error) {
			r := golangsdk.Result{}
			_, r.Err = client.Get(url, &r.Body, &golangsdk.RequestOpts{
				MoreHeaders: map[string]string{
					"Content-Type": "application/json",
					"X-Language":   "en-us",
				}})
			if r.Err != nil {
				return nil, "", nil
			}

			status, err := navigateValue(r.Body, []string{"graph", "status"}, nil)
			if err != nil {
				return nil, "", nil
			}
			return r.Body, status.(string), nil
		},
	)
}

func asyncWaitGesGraphV1Delete(d *schema.ResourceData, config *config.Config, result interface{},
	client *golangsdk.ServiceClient, timeout time.Duration) (interface{}, error) {

	data := make(map[string]interface{})
	pathParameters := map[string][]string{
		"jobId": []string{"jobId"},
	}
	for key, path := range pathParameters {
		value, err := navigateValue(result, path, nil)
		if err != nil {
			return nil, fmtp.Errorf("Error retrieving async operation path parameter, err=%s", err)
		}
		data[key] = value
	}

	url, err := replaceVars(d, "graphs/{id}/jobs/{jobId}/status", data)
	if err != nil {
		return nil, err
	}
	url = client.ServiceURL(url)

	return waitToFinish(
		[]string{"success"},
		[]string{"waiting", "running"},
		timeout, 1*time.Second,
		func() (interface{}, string, error) {
			r := golangsdk.Result{}
			_, r.Err = client.Get(url, &r.Body, &golangsdk.RequestOpts{
				MoreHeaders: map[string]string{
					"Content-Type": "application/json",
					"X-Language":   "en-us",
				}})
			if r.Err != nil {
				return nil, "", nil
			}

			status, err := navigateValue(r.Body, []string{"status"}, nil)
			if err != nil {
				return nil, "", nil
			}
			return r.Body, status.(string), nil
		},
	)
}

func sendGesGraphV1ReadRequest(d *schema.ResourceData, client *golangsdk.ServiceClient) (interface{}, error) {
	url, err := replaceVars(d, "graphs/{id}", nil)
	if err != nil {
		return nil, err
	}
	url = client.ServiceURL(url)

	r := golangsdk.Result{}
	_, r.Err = client.Get(url, &r.Body, &golangsdk.RequestOpts{
		MoreHeaders: map[string]string{"Content-Type": "application/json"}})
	if r.Err != nil {
		return nil, fmtp.Errorf("Error running api(read) for resource(GesGraphV1), err=%s", r.Err)
	}

	v, err := navigateValue(r.Body, []string{"graph"}, nil)
	if err != nil {
		return nil, err
	}
	return v, nil
}

func fillGesGraphV1ReadRespBody(body interface{}) interface{} {
	result := make(map[string]interface{})
	val, ok := body.(map[string]interface{})
	if !ok {
		val = make(map[string]interface{})
	}

	if v, ok := val["azCode"]; ok {
		result["azCode"] = v
	} else {
		result["azCode"] = nil
	}

	if v, ok := val["created"]; ok {
		result["created"] = v
	} else {
		result["created"] = nil
	}

	if v, ok := val["dataStoreVersion"]; ok {
		result["dataStoreVersion"] = v
	} else {
		result["dataStoreVersion"] = nil
	}

	if v, ok := val["edgesetDefaultLabel"]; ok {
		result["edgesetDefaultLabel"] = v
	} else {
		result["edgesetDefaultLabel"] = nil
	}

	if v, ok := val["edgesetFormat"]; ok {
		result["edgesetFormat"] = v
	} else {
		result["edgesetFormat"] = nil
	}

	if v, ok := val["edgesetPath"]; ok {
		result["edgesetPath"] = fillGesGraphV1ReadRespEdgesetPath(v)
	} else {
		result["edgesetPath"] = nil
	}

	if v, ok := val["graphSizeTypeIndex"]; ok {
		result["graphSizeTypeIndex"] = v
	} else {
		result["graphSizeTypeIndex"] = nil
	}

	if v, ok := val["id"]; ok {
		result["id"] = v
	} else {
		result["id"] = nil
	}

	if v, ok := val["name"]; ok {
		result["name"] = v
	} else {
		result["name"] = nil
	}

	if v, ok := val["privateIp"]; ok {
		result["privateIp"] = v
	} else {
		result["privateIp"] = nil
	}

	if v, ok := val["publicIp"]; ok {
		result["publicIp"] = v
	} else {
		result["publicIp"] = nil
	}

	if v, ok := val["regionCode"]; ok {
		result["regionCode"] = v
	} else {
		result["regionCode"] = nil
	}

	if v, ok := val["schemaPath"]; ok {
		result["schemaPath"] = fillGesGraphV1ReadRespSchemaPath(v)
	} else {
		result["schemaPath"] = nil
	}

	if v, ok := val["securityGroupId"]; ok {
		result["securityGroupId"] = v
	} else {
		result["securityGroupId"] = nil
	}

	if v, ok := val["status"]; ok {
		result["status"] = v
	} else {
		result["status"] = nil
	}

	if v, ok := val["subnetId"]; ok {
		result["subnetId"] = v
	} else {
		result["subnetId"] = nil
	}

	if v, ok := val["updated"]; ok {
		result["updated"] = v
	} else {
		result["updated"] = nil
	}

	if v, ok := val["vertexsetDefaultLabel"]; ok {
		result["vertexsetDefaultLabel"] = v
	} else {
		result["vertexsetDefaultLabel"] = nil
	}

	if v, ok := val["vertexsetFormat"]; ok {
		result["vertexsetFormat"] = v
	} else {
		result["vertexsetFormat"] = nil
	}

	if v, ok := val["vertexsetPath"]; ok {
		result["vertexsetPath"] = fillGesGraphV1ReadRespVertexsetPath(v)
	} else {
		result["vertexsetPath"] = nil
	}

	if v, ok := val["vpcId"]; ok {
		result["vpcId"] = v
	} else {
		result["vpcId"] = nil
	}

	return result
}

func fillGesGraphV1ReadRespEdgesetPath(value interface{}) interface{} {
	if value == nil {
		return nil
	}

	value1, ok := value.([]interface{})
	if !ok || len(value1) == 0 {
		return nil
	}

	n := len(value1)
	result := make([]interface{}, n, n)
	for i := 0; i < n; i++ {
		val := make(map[string]interface{})
		item := value1[i].(map[string]interface{})

		if v, ok := item["jobId"]; ok {
			val["jobId"] = v
		} else {
			val["jobId"] = nil
		}

		if v, ok := item["path"]; ok {
			val["path"] = v
		} else {
			val["path"] = nil
		}

		if v, ok := item["status"]; ok {
			val["status"] = v
		} else {
			val["status"] = nil
		}

		result[i] = val
	}

	return result
}

func fillGesGraphV1ReadRespSchemaPath(value interface{}) interface{} {
	if value == nil {
		return nil
	}

	value1, ok := value.([]interface{})
	if !ok || len(value1) == 0 {
		return nil
	}

	n := len(value1)
	result := make([]interface{}, n, n)
	for i := 0; i < n; i++ {
		val := make(map[string]interface{})
		item := value1[i].(map[string]interface{})

		if v, ok := item["jobId"]; ok {
			val["jobId"] = v
		} else {
			val["jobId"] = nil
		}

		if v, ok := item["path"]; ok {
			val["path"] = v
		} else {
			val["path"] = nil
		}

		if v, ok := item["status"]; ok {
			val["status"] = v
		} else {
			val["status"] = nil
		}

		result[i] = val
	}

	return result
}

func fillGesGraphV1ReadRespVertexsetPath(value interface{}) interface{} {
	if value == nil {
		return nil
	}

	value1, ok := value.([]interface{})
	if !ok || len(value1) == 0 {
		return nil
	}

	n := len(value1)
	result := make([]interface{}, n, n)
	for i := 0; i < n; i++ {
		val := make(map[string]interface{})
		item := value1[i].(map[string]interface{})

		if v, ok := item["jobId"]; ok {
			val["jobId"] = v
		} else {
			val["jobId"] = nil
		}

		if v, ok := item["path"]; ok {
			val["path"] = v
		} else {
			val["path"] = nil
		}

		if v, ok := item["status"]; ok {
			val["status"] = v
		} else {
			val["status"] = nil
		}

		result[i] = val
	}

	return result
}

func setGesGraphV1Properties(d *schema.ResourceData, response map[string]interface{}) error {
	opts := resourceGesGraphV1UserInputParams(d)

	v, err := navigateValue(response, []string{"read", "azCode"}, nil)
	if err != nil {
		return fmtp.Errorf("Error reading Graph:availability_zone, err: %s", err)
	}
	if err = d.Set("availability_zone", v); err != nil {
		return fmtp.Errorf("Error setting Graph:availability_zone, err: %s", err)
	}

	v, err = navigateValue(response, []string{"read", "created"}, nil)
	if err != nil {
		return fmtp.Errorf("Error reading Graph:created, err: %s", err)
	}
	if err = d.Set("created", v); err != nil {
		return fmtp.Errorf("Error setting Graph:created, err: %s", err)
	}

	v, _ = opts["edgeset_path"]
	v, err = flattenGesGraphV1EdgesetPath(response, nil, v)
	if err != nil {
		return fmtp.Errorf("Error reading Graph:edgeset_path, err: %s", err)
	}
	if err = d.Set("edgeset_path", v); err != nil {
		return fmtp.Errorf("Error setting Graph:edgeset_path, err: %s", err)
	}

	v, err = navigateValue(response, []string{"read", "graphSizeTypeIndex"}, nil)
	if err != nil {
		return fmtp.Errorf("Error reading Graph:graph_size_type, err: %s", err)
	}
	if err = d.Set("graph_size_type", v); err != nil {
		return fmtp.Errorf("Error setting Graph:graph_size_type, err: %s", err)
	}

	v, err = navigateValue(response, []string{"read", "name"}, nil)
	if err != nil {
		return fmtp.Errorf("Error reading Graph:name, err: %s", err)
	}
	if err = d.Set("name", v); err != nil {
		return fmtp.Errorf("Error setting Graph:name, err: %s", err)
	}

	v, err = navigateValue(response, []string{"read", "privateIp"}, nil)
	if err != nil {
		return fmtp.Errorf("Error reading Graph:private_ip, err: %s", err)
	}
	if err = d.Set("private_ip", v); err != nil {
		return fmtp.Errorf("Error setting Graph:private_ip, err: %s", err)
	}

	v, err = navigateValue(response, []string{"read", "publicIp"}, nil)
	if err != nil {
		return fmtp.Errorf("Error reading Graph:public_ip, err: %s", err)
	}
	if err = d.Set("public_ip", v); err != nil {
		return fmtp.Errorf("Error setting Graph:public_ip, err: %s", err)
	}

	v, err = navigateValue(response, []string{"read", "regionCode"}, nil)
	if err != nil {
		return fmtp.Errorf("Error reading Graph:region, err: %s", err)
	}
	if err = d.Set("region", v); err != nil {
		return fmtp.Errorf("Error setting Graph:region, err: %s", err)
	}

	v, _ = opts["schema_path"]
	v, err = flattenGesGraphV1SchemaPath(response, nil, v)
	if err != nil {
		return fmtp.Errorf("Error reading Graph:schema_path, err: %s", err)
	}
	if err = d.Set("schema_path", v); err != nil {
		return fmtp.Errorf("Error setting Graph:schema_path, err: %s", err)
	}

	v, err = navigateValue(response, []string{"read", "securityGroupId"}, nil)
	if err != nil {
		return fmtp.Errorf("Error reading Graph:security_group_id, err: %s", err)
	}
	if err = d.Set("security_group_id", v); err != nil {
		return fmtp.Errorf("Error setting Graph:security_group_id, err: %s", err)
	}

	v, err = navigateValue(response, []string{"read", "subnetId"}, nil)
	if err != nil {
		return fmtp.Errorf("Error reading Graph:subnet_id, err: %s", err)
	}
	if err = d.Set("subnet_id", v); err != nil {
		return fmtp.Errorf("Error setting Graph:subnet_id, err: %s", err)
	}

	v, err = navigateValue(response, []string{"read", "dataStoreVersion"}, nil)
	if err != nil {
		return fmtp.Errorf("Error reading Graph:version, err: %s", err)
	}
	if err = d.Set("version", v); err != nil {
		return fmtp.Errorf("Error setting Graph:version, err: %s", err)
	}

	v, _ = opts["vertexset_path"]
	v, err = flattenGesGraphV1VertexsetPath(response, nil, v)
	if err != nil {
		return fmtp.Errorf("Error reading Graph:vertexset_path, err: %s", err)
	}
	if err = d.Set("vertexset_path", v); err != nil {
		return fmtp.Errorf("Error setting Graph:vertexset_path, err: %s", err)
	}

	v, err = navigateValue(response, []string{"read", "vpcId"}, nil)
	if err != nil {
		return fmtp.Errorf("Error reading Graph:vpc_id, err: %s", err)
	}
	if err = d.Set("vpc_id", v); err != nil {
		return fmtp.Errorf("Error setting Graph:vpc_id, err: %s", err)
	}

	return nil
}

func flattenGesGraphV1EdgesetPath(d interface{}, arrayIndex map[string]int, currentValue interface{}) (interface{}, error) {
	n := 0
	hasInitValue := true
	result, ok := currentValue.([]interface{})
	if !ok || len(result) == 0 {
		v, err := navigateValue(d, []string{"read", "edgesetPath"}, arrayIndex)
		if err != nil {
			return nil, err
		}
		if v1, ok := v.([]interface{}); ok && len(v1) > 0 {
			n = len(v1)
		} else {
			return currentValue, nil
		}
		result = make([]interface{}, 0, n)
		hasInitValue = false
	} else {
		n = len(result)
	}

	newArrayIndex := make(map[string]int)
	if arrayIndex != nil {
		for k, v := range arrayIndex {
			newArrayIndex[k] = v
		}
	}

	for i := 0; i < n; i++ {
		newArrayIndex["read.edgesetPath"] = i

		var r map[string]interface{}
		if len(result) >= (i+1) && result[i] != nil {
			r = result[i].(map[string]interface{})
		} else {
			r = make(map[string]interface{})
		}

		v, err := navigateValue(d, []string{"read", "edgesetPath", "path"}, newArrayIndex)
		if err != nil {
			return nil, fmtp.Errorf("Error reading Graph:path, err: %s", err)
		}
		r["path"] = v

		v, err = navigateValue(d, []string{"read", "edgesetPath", "status"}, newArrayIndex)
		if err != nil {
			return nil, fmtp.Errorf("Error reading Graph:status, err: %s", err)
		}
		r["status"] = v

		if len(result) >= (i + 1) {
			if result[i] == nil {
				result[i] = r
			}
		} else {
			for _, v := range r {
				if v != nil {
					result = append(result, r)
					break
				}
			}
		}
	}

	if hasInitValue || len(result) > 0 {
		return result, nil
	}
	return currentValue, nil
}

func flattenGesGraphV1SchemaPath(d interface{}, arrayIndex map[string]int, currentValue interface{}) (interface{}, error) {
	n := 0
	hasInitValue := true
	result, ok := currentValue.([]interface{})
	if !ok || len(result) == 0 {
		v, err := navigateValue(d, []string{"read", "schemaPath"}, arrayIndex)
		if err != nil {
			return nil, err
		}
		if v1, ok := v.([]interface{}); ok && len(v1) > 0 {
			n = len(v1)
		} else {
			return currentValue, nil
		}
		result = make([]interface{}, 0, n)
		hasInitValue = false
	} else {
		n = len(result)
	}

	newArrayIndex := make(map[string]int)
	if arrayIndex != nil {
		for k, v := range arrayIndex {
			newArrayIndex[k] = v
		}
	}

	for i := 0; i < n; i++ {
		newArrayIndex["read.schemaPath"] = i

		var r map[string]interface{}
		if len(result) >= (i+1) && result[i] != nil {
			r = result[i].(map[string]interface{})
		} else {
			r = make(map[string]interface{})
		}

		v, err := navigateValue(d, []string{"read", "schemaPath", "path"}, newArrayIndex)
		if err != nil {
			return nil, fmtp.Errorf("Error reading Graph:path, err: %s", err)
		}
		r["path"] = v

		v, err = navigateValue(d, []string{"read", "schemaPath", "status"}, newArrayIndex)
		if err != nil {
			return nil, fmtp.Errorf("Error reading Graph:status, err: %s", err)
		}
		r["status"] = v

		if len(result) >= (i + 1) {
			if result[i] == nil {
				result[i] = r
			}
		} else {
			for _, v := range r {
				if v != nil {
					result = append(result, r)
					break
				}
			}
		}
	}

	if hasInitValue || len(result) > 0 {
		return result, nil
	}
	return currentValue, nil
}

func flattenGesGraphV1VertexsetPath(d interface{}, arrayIndex map[string]int, currentValue interface{}) (interface{}, error) {
	n := 0
	hasInitValue := true
	result, ok := currentValue.([]interface{})
	if !ok || len(result) == 0 {
		v, err := navigateValue(d, []string{"read", "vertexsetPath"}, arrayIndex)
		if err != nil {
			return nil, err
		}
		if v1, ok := v.([]interface{}); ok && len(v1) > 0 {
			n = len(v1)
		} else {
			return currentValue, nil
		}
		result = make([]interface{}, 0, n)
		hasInitValue = false
	} else {
		n = len(result)
	}

	newArrayIndex := make(map[string]int)
	if arrayIndex != nil {
		for k, v := range arrayIndex {
			newArrayIndex[k] = v
		}
	}

	for i := 0; i < n; i++ {
		newArrayIndex["read.vertexsetPath"] = i

		var r map[string]interface{}
		if len(result) >= (i+1) && result[i] != nil {
			r = result[i].(map[string]interface{})
		} else {
			r = make(map[string]interface{})
		}

		v, err := navigateValue(d, []string{"read", "vertexsetPath", "path"}, newArrayIndex)
		if err != nil {
			return nil, fmtp.Errorf("Error reading Graph:path, err: %s", err)
		}
		r["path"] = v

		v, err = navigateValue(d, []string{"read", "vertexsetPath", "status"}, newArrayIndex)
		if err != nil {
			return nil, fmtp.Errorf("Error reading Graph:status, err: %s", err)
		}
		r["status"] = v

		if len(result) >= (i + 1) {
			if result[i] == nil {
				result[i] = r
			}
		} else {
			for _, v := range r {
				if v != nil {
					result = append(result, r)
					break
				}
			}
		}
	}

	if hasInitValue || len(result) > 0 {
		return result, nil
	}
	return currentValue, nil
}
